// This file is part of X3D.
//
// X3D is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// X3D is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with X3D. If not, see <http://www.gnu.org/licenses/>.

#include "X3D_init.h"
#include "X3D_log.h"
#include "X3D_assert.h"
#include "X3D_enginestate.h"

void x3d_init(X3D_InitSettings* settings) {
  x3d_log(X3D_INFO, "X3D init");  
  x3d_enginestate_init();
  x3d_platform_init(settings);
}

void x3d_cleanup(void) {
  x3d_log(X3D_INFO, "X3D cleanup");
  x3d_platform_cleanup();
}

// This file is part of X3D.
//
// X3D is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// X3D is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with X3D. If not, see <http://www.gnu.org/licenses/>.

#include "X3D_common.h"
#include "X3D_enginestate.h"

static X3D_EngineState x3d_global_enginestate;
X3D_EngineState* x3d_state;

///////////////////////////////////////////////////////////////////////////////
/// Initializes the global engine state.
///
X3D_INTERNAL void x3d_enginestate_init(void) {
  x3d_state = &x3d_global_enginestate;
  
  x3d_segmentmanager_init(10, 2000);
}// This file is part of X3D.
//
// X3D is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// X3D is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with X3D. If not, see <http://www.gnu.org/licenses/>.

#include "X3D_common.h"
#include "X3D_segmentbuilder.h"
#include "X3D_enginestate.h"

///////////////////////////////////////////////////////////////////////////////
/// Creates a new uncompressed segment that can be edited and joined with
///   other segments.
///
/// @param prism - prism that describes the geometry of the segment
///
/// @return A pointer to the uncompressed segment.
/// @note All faces of the segment are set to not be connected to anything.
/// @note For internal use only.
///////////////////////////////////////////////////////////////////////////////
X3D_INTERNAL X3D_UncompressedSegment* x3d_segmentbuilder_add_uncompressed_segment(X3D_Prism3D* prism) {  
  X3D_UncompressedSegment* seg = (X3D_UncompressedSegment*)x3d_segmentmanager_add(
    x3d_uncompressedsegment_size(prism->base_v));
  
  seg->face_offset = x3d_uncompressedsegment_face_offset(prism->base_v);
  
  // Copy over the prism data
  x3d_prism3d_copy(&seg->prism, prism);
  
  // Initialize all faces to have nothing connected to them
  uint16 i;
  X3D_UncompressedSegmentFace* face = x3d_uncompressedsegment_get_faces(seg);
  uint16 total_f = x3d_prism3d_total_f(prism->base_v);
  
  for(i = 0; i < total_f; ++i) {
    face[i].portal_seg_face = X3D_FACE_NONE;
  }
  
  seg->base.flags = X3D_SEGMENT_UNCOMPRESSED;
  seg->base.base_v = prism->base_v;
  
  return seg;
}

///////////////////////////////////////////////////////////////////////////////
/// Creates a new uncompressed segment that is not connected to anything else.
///
/// @param prism  - the prism that describes the geometry of the segment
///
/// @return The id of the uncompressed segment.
///////////////////////////////////////////////////////////////////////////////
uint16 x3d_segmentbuilder_add_unconnected_segment(X3D_Prism3D* prism) {
  return x3d_segmentbuilder_add_uncompressed_segment(prism)->base.id;
}

uint16 x3d_segmentbuilder_add_extruded_segment(X3D_SegFaceID id, int16 dist) {
  
}

uint16 x3d_segmentbuilder_add_connecting_segment(X3D_SegFaceID a, X3D_SegFaceID b) {
  
}

// This file is part of X3D.
//
// X3D is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// X3D is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with X3D. If not, see <http://www.gnu.org/licenses/>.

///////////////////////////////////////////////////////////////////////////////
/// The main game loop.
///////////////////////////////////////////////////////////////////////////////
void x3d_game_loop() {
  
}

// This file is part of X3D.
//
// X3D is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// X3D is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with X3D. If not, see <http://www.gnu.org/licenses/>.

#include <SDL2/SDL.h>

#include "X3D_common.h"
#include "X3D_init.h"
#include "X3D_keys.h"
#include "X3D_assert.h"

// Total number of keys that SDL defines
#define SDL_TOTAL_KEYS 322



// Holds whether each key is currently being pressed
static _Bool sdl_keys[SDL_TOTAL_KEYS];

// The max X3D key that has been set (will be used to determine how many bytes)
//    of the keystate need to be transferred with multiplayer.
static int16 max_key;

// Holds which X3D keys are currently being pressed
static uint32 key_state;

// Holds which keys have been pressed since the last time checked
static uint32 key_pressed_state;

// Maps an SDL key to an X3D key
static int32 key_map[X3D_MAX_KEYS];


X3D_INTERNAL void x3d_platform_keys_init(X3D_InitSettings* settings) {
  x3d_log(X3D_INFO, "Key mapper init\n");
  
  for(int16 i = 0; i < SDL_TOTAL_KEYS; ++i)
    sdl_keys[i] = X3D_FALSE;
  
  for(int16 i = 0; i < X3D_MAX_KEYS; ++i) {
    key_map[i] = X3D_KEY_NONE;
  }
  
  key_state = 0;
  key_pressed_state = 0;
}

void x3d_key_map_pc(X3D_Key x3d_key, int32 sdl_key) {
  int id = 0;
  
  x3d_assert(x3d_key != 0);
  
  while((x3d_key & 1) == 0) {
    x3d_key >>= 1;
    ++id;
  }
  
  // Multiple keys aren't supported yet
  x3d_assert(x3d_key == 1);
  
  key_map[id] = sdl_key;
  
  if(sdl_key != X3D_KEY_NONE)
    x3d_log(X3D_INFO, "Mapped key '%s' to 'X3D_KEY_%d'", SDL_GetKeyName(sdl_key), id);
  else
    x3d_log(X3D_INFO, "Reset key 'X3D_KEY_%d'", id);
}

X3D_PLATFORM void x3d_read_keys() {
  int16 i;
  SDL_Event event;
  
  // Process the SDL events
  /// @todo Add SDL_QUIT
  while(SDL_PollEvent(&event)) {
    switch(event.type) {
      case SDL_KEYDOWN:
        printf("Key: %d\n", event.key.keysym.sym);
        sdl_keys[event.key.keysym.sym] = X3D_TRUE;
        break;
        
      case SDL_KEYUP:
        sdl_keys[event.key.keysym.sym] = X3D_FALSE;
        break;
        
      default:
        break;
    }
  }
  
  // Update the X3D keystate based on which keys are being pressed
  key_state = 0;
  
  for(i = X3D_MAX_KEYS - 1; i >= 0; --i) {
    key_state <<= 1;
    
    if(key_map[i] != X3D_KEY_NONE)
      key_state |= sdl_keys[key_map[i]];
  }
}

_Bool x3d_key_down(X3D_Key key) {
  return key_state & key;
}

// This file is part of X3D.
//
// X3D is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// X3D is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with X3D. If not, see <http://www.gnu.org/licenses/>.

#include "X3D_common.h"
#include "X3D_init.h"

#include "X3D_platform_init.h"

/// @todo this should return whether initialization succeeded
X3D_INTERNAL void x3d_platform_init(X3D_InitSettings* settings) {
  x3d_platform_screen_init(settings);
  x3d_platform_keys_init(settings);
}

X3D_PLATFORM
X3D_INTERNAL
void x3d_platform_cleanup(void) {
  x3d_platform_screen_cleanup();
}// This file is part of X3D.
//
// X3D is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// X3D is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with X3D. If not, see <http://www.gnu.org/licenses/>.

#include <stdlib.h>
#include <execinfo.h>
#include <stdio.h>
#include <unistd.h>

#include "X3D_common.h"
#include "X3D_log.h"

void x3d_platform_assert_failed(const char* condition, const char* file, int16 line) {
  x3d_log(X3D_ERROR, "Assertion failed!\nFile: %s\nline: %d\n\t%s\n", file, line, condition);
  
  // Stack trace
  void* ptr[128];
  
  fprintf(stderr, "Stack trace:\n\n");
  
  int size = backtrace(ptr, 128);
  backtrace_symbols_fd(ptr, size, STDOUT_FILENO);
  
  fprintf(stderr, "\n");
  
  /// @todo: replace with x3d_quit
  exit(0);
}

// This file is part of X3D.
//
// X3D is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// X3D is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with X3D. If not, see <http://www.gnu.org/licenses/>.

#include <SDL2/SDL.h>

#include "X3D_common.h"
#include "X3D_init.h"
#include "X3D_screen.h"
#include "X3D_enginestate.h"
#include "X3D_trig.h"

static SDL_Window* window;
static SDL_Surface* window_surface;
static int16 screen_w;
static int16 screen_h;
static int16 screen_scale;

X3D_INTERNAL _Bool x3d_platform_screen_init(X3D_InitSettings* init) {
  x3d_log(X3D_INFO, "SDL init");
  
  if(SDL_Init(SDL_INIT_VIDEO) != 0) {
    x3d_log(X3D_ERROR, "Failed to init SDL");
    return X3D_FALSE;
  }
  
  screen_w = init->screen_w;
  screen_h = init->screen_h;
  screen_scale = init->screen_scale;
  
  x3d_state->screen_manager.w = screen_w;
  x3d_state->screen_manager.h = screen_h;
  x3d_state->screen_manager.center.x = screen_w / 2;
  x3d_state->screen_manager.center.y = screen_h / 2;
  x3d_state->screen_manager.fov = init->fov;
  x3d_state->screen_manager.scale = div_int16_by_fp0x16(screen_w / 2, x3d_tan(init->fov / 2));
  
  x3d_log(X3D_INFO, "Create window (w=%d, h=%d, pix_scale=%d, render_scale=%d)",
          init->screen_w, init->screen_h, init->screen_scale, x3d_state->screen_manager.scale);
  
  window = SDL_CreateWindow(
    "X3D",
    SDL_WINDOWPOS_UNDEFINED,
    SDL_WINDOWPOS_UNDEFINED,
    init->screen_w * init->screen_scale,
    init->screen_h * init->screen_scale,
    SDL_WINDOW_OPENGL | (init->fullscreen ? SDL_WINDOW_FULLSCREEN : 0)
  );
  
  if(!window) {
    x3d_log(X3D_ERROR, "Failed to create window");
    return X3D_FALSE;
  }
  
  x3d_log(X3D_INFO, "Window created");
  
  window_surface = SDL_GetWindowSurface(window);
  
  return X3D_TRUE;
  
}

X3D_INTERNAL void x3d_platform_screen_cleanup(void) {
  SDL_DestroyWindow(window);
  SDL_Quit();
}


#define PURPLE (16 | (16 << 10))

static uint32 map_color_to_uint32(X3D_Color color) {
  const uint16 mask = (1 << 5) - 1;
  uint16 red = 255 * (color & mask) / 31;
  uint16 green = 255 * ((color >> 5) & mask) / 31;
  uint16 blue = 255 * ((color >> 10) & mask) / 31;
  
  return SDL_MapRGB(window_surface->format, red, green, blue);
}


void x3d_screen_flip() {
  SDL_UpdateWindowSurface(window);
}

void x3d_screen_clear(X3D_Color color) {
  SDL_FillRect(window_surface, NULL, map_color_to_uint32(color));
}

void x3d_screen_draw_pix(int16 x, int16 y, X3D_Color color) {
  uint32 c = map_color_to_uint32(color);
  
  if(x < 0 || x >= screen_w || y < 0 || y >= screen_h)
    return;
  
  for(int32 i = 0; i < screen_scale; ++i) {
    for(int32 d = 0; d < screen_scale; ++d) {
      int32 xx = x * screen_scale + d;
      int32 yy = y * screen_scale + i;
      
      ((uint32 *)window_surface->pixels)[yy * window_surface->w + xx] = c;
    }
  }
}

void x3d_screen_draw_line(int16 x0, int16 y0, int16 x1, int16 y1, X3D_Color color) {
  int dx = abs(x1-x0), sx = x0<x1 ? 1 : -1;
  int dy = abs(y1-y0), sy = y0<y1 ? 1 : -1; 
  int err = (dx>dy ? dx : -dy)/2, e2;
 
  for(;;){
    x3d_screen_draw_pix(x0, y0, color);
    if (x0==x1 && y0==y1) break;
    e2 = err;
    if (e2 >-dx) { err -= dy; x0 += sx; }
    if (e2 < dy) { err += dx; y0 += sy; }
  }
}

X3D_Color x3d_rgb_to_color(uint8 r, uint8 g, uint8 b) {
  return (31 * (uint16)r / 255) +
    ((31 * (uint16)g / 255) << 5) +
    ((31 * (uint16)b / 255) << 10);
}

void x3d_color_to_rgb(X3D_Color color, uint8* r, uint8* g, uint8* b) {
  const uint16 mask = (1 << 5) - 1;
  *r = 255 * (color & mask) / 31;
  *g = 255 * ((color >> 5) & mask) / 31;
  *b = 255 * ((color >> 10) & mask) / 31;
}


// This file is part of X3D.
//
// X3D is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// X3D is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with X3D. If not, see <http://www.gnu.org/licenses/>.

#include "X3D_common.h"
#include "X3D_segment.h"
#include "X3D_enginestate.h"
#include "memory/X3D_varsizeallocator.h"
#include "X3D_prism.h"

///////////////////////////////////////////////////////////////////////////////
/// Initializes the segment manager.
///
/// @param max_segments   - maximum number of segments
/// @param seg_pool_size  - memory to set aside for allocating segments
///
/// @return Nothing.
///////////////////////////////////////////////////////////////////////////////
X3D_INTERNAL void x3d_segmentmanager_init(uint16 max_segments, uint16 seg_pool_size) {
  X3D_SegmentManager* seg_manager = x3d_segmentmanager_get();
  
  x3d_log(X3D_INFO, "Segment manager init");
  
  x3d_varsizeallocator_init(&seg_manager->alloc, max_segments, seg_pool_size);
  
  // Clear the cache
  uint16 i;
  
  for(i = 0; i < X3D_SEGMENT_CACHE_SIZE; ++i) {
    seg_manager->cache.entry[i].seg.base.id = X3D_SEGMENT_NONE;
  }
}

///////////////////////////////////////////////////////////////////////////////
/// Creates a new segment.
///////////////////////////////////////////////////////////////////////////////
X3D_SegmentBase* x3d_segmentmanager_add(uint16 size) {
  X3D_SegmentManager* seg_manager = x3d_segmentmanager_get();
  uint16 id;
  X3D_SegmentBase* seg = x3d_varsizeallocator_alloc(&seg_manager->alloc, size, &id);
  
  seg->id = id;
  seg->flags = 0;
  
  return seg;
}

///////////////////////////////////////////////////////////////////////////////
/// Gets a pointer to the interal representation of a segment.
///
/// @param id - ID of the segment to get
///
/// @return The addess of the interal segment representation.
///////////////////////////////////////////////////////////////////////////////
X3D_INTERNAL X3D_SegmentBase* x3d_segmentmanager_get_internal(uint16 id) {
  X3D_SegmentManager* seg_manager = x3d_segmentmanager_get();
  
  return x3d_varsizeallocator_get(&seg_manager->alloc, id);
}


///////////////////////////////////////////////////////////////////////////////
/// Decompresses a segment and loads it into cache, if it's not already there.
///
/// @param id - id of the segment to load
///
/// @return The address of the uncompressed segment.
/// @note This address is only valid while the segment remains in cache!
/// @todo Implemented some sort of locking mechinism?
/// @todo Implement LRU strategy for deciding which block should be replaced.
///////////////////////////////////////////////////////////////////////////////
X3D_UncompressedSegment* x3d_segmentmanager_load(uint16 id) {
  X3D_SegmentBase* seg = x3d_segmentmanager_get_internal(id);
  X3D_SegmentManager* seg_manager = x3d_segmentmanager_get();
  
  // Currently only support uncompressed segments
  x3d_assert(seg->flags & X3D_SEGMENT_UNCOMPRESSED);
  
  // The segment is already loaded into the cache
  if(seg->flags & X3D_SEGMENT_IN_CACHE) {
    uint16 cache_entry = seg->flags & (X3D_SEGMENT_CACHE_SIZE - 1);
    
    X3D_SegmentCacheEntry* entry = &seg_manager->cache.entry[cache_entry];
    
    /// @todo Move the segment back to the tail of the queue (for the LRU
    ///   strategy).
    return &entry->seg;
  }
  
  uint16 i;
  for(i = 0; i < X3D_SEGMENT_CACHE_SIZE; ++i) {
    if(seg_manager->cache.entry[i].seg.base.id == X3D_SEGMENT_NONE) {
      seg_manager->cache.entry[i].seg = *((X3D_UncompressedSegment *)seg);
      seg->flags |= X3D_SEGMENT_IN_CACHE | i;
      
      x3d_log(X3D_INFO, "Moved segment %d into cache (entry %d)", id, i);
      
      
      return &seg_manager->cache.entry[i].seg;
    }
  }
  
  x3d_assert(!"Out of segments!");
  return NULL;
}











// This file is part of X3D.
//
// X3D is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// X3D is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with X3D. If not, see <http://www.gnu.org/licenses/>.

#include <stdio.h>
#include <stdarg.h>

#include "X3D_log.h"

#define ANSI_COLOR_RED     "\x1b[1;31m"
#define ANSI_COLOR_GREEN   "\x1b[1;32m"
#define ANSI_COLOR_YELLOW  "\x1b[1;33m"
#define ANSI_COLOR_BLUE    "\x1b[1;34m"
#define ANSI_COLOR_MAGENTA "\x1b[1;35m"
#define ANSI_COLOR_CYAN    "\x1b[1;36m"
#define ANSI_COLOR_RESET   "\x1b[0m"

///////////////////////////////////////////////////////////////////////////////
/// Prints a message to the log.
/// 
/// @param type     - type of message being displayed
/// @param format   - printf-like format string
///////////////////////////////////////////////////////////////////////////////
void x3d_log(X3D_LogType type, const char* format, ...) {
  va_list list;
  const char* color;
  const char* status[3] = {
    ANSI_COLOR_GREEN "[INFO]" ANSI_COLOR_RESET,
    ANSI_COLOR_YELLOW "[WARN]" ANSI_COLOR_RESET,
    ANSI_COLOR_RED "[ERR ]" ANSI_COLOR_RESET
  };
  
  printf("%s ", status[type]);
  va_start(list, format);
  vprintf(format, list);
  printf("\n");
}// This file is part of X3D.
//
// X3D is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// X3D is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with X3D. If not, see <http://www.gnu.org/licenses/>.

#include "X3D_common.h"
#include "memory/X3D_list.h"
#include "X3D_assert.h"

///////////////////////////////////////////////////////////////////////////////
/// Initializes a list of uint16's.
///
/// @param list     - list
/// @param mem      - memory for the list
/// @param mem_size - size of mem
///
/// @return Nothing.
/// @note mem_size must be even.
///////////////////////////////////////////////////////////////////////////////
void x3d_list_uint16_init(X3D_List_uint16* list, void* mem, uint16 mem_size) {
  // Make sure we have an even memory size!
  x3d_assert((mem_size & 1) == 0);
  
  list->data = mem;
  list->capacity = mem_size / sizeof(uint16);
  list->size = 0;
}

///////////////////////////////////////////////////////////////////////////////
/// Adds an element to the end of a list of uint16's.
///
/// @param list - list
/// @param val  - value to add
///
/// @return The index in the list the value was added to.
///////////////////////////////////////////////////////////////////////////////
uint16 x3d_list_uint16_add(X3D_List_uint16* list, uint16 val) {
  // Prevent list overflow
  x3d_assert(list->size < list->capacity);
  
  list->data[list->size] = val;
  
  return list->size++;
}

///////////////////////////////////////////////////////////////////////////////
/// Gets an element from a list.
///
/// @param list   - list
/// @param index  - index in the list
///
/// @param The element from the list.
///////////////////////////////////////////////////////////////////////////////
uint16 x3d_list_uint16_get(X3D_List_uint16* list, uint16 index) {
  // Check for out of bounds
  x3d_assert(index < list->capacity);
  
  return list->data[index];
}// This file is part of X3D.
//
// X3D is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// X3D is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with X3D. If not, see <http://www.gnu.org/licenses/>.

#include "X3D_common.h"
#include "memory/X3D_stack.h"
#include "X3D_assert.h"

///////////////////////////////////////////////////////////////////////////////
/// Initializes an X3D_Stack.
///
/// @param stack    - stack
/// @param mem      - memory for the stack
/// @param mem_size - size of the memory for the stack
///////////////////////////////////////////////////////////////////////////////
void x3d_stack_init(X3D_Stack* stack, void* mem, uint16 mem_size) {
  stack->base = mem;
  stack->size = mem_size;
  
  // The stack starts at the end of memory and is decremented before each
  // alloc
  stack->ptr = mem + mem_size;
}

///////////////////////////////////////////////////////////////////////////////
/// Allocates space on a stack.
///
/// @param stack  - stack
/// @param size   - size of chunk to allocate
///
/// @return A pointer to the chunk of memory that is at least enough to hold
///   the requested size.
/// @note The chunk may be bigger by a byte because 68k requires memory to be
///   aligned to a 2-byte boundry.
///
/// @todo Make this safe for devices that require 4-byte memory alignment.
///////////////////////////////////////////////////////////////////////////////
void* x3d_stack_alloc(X3D_Stack* stack, uint16 size) {
  // Allocate space that is guaranteed to have an even size
  // (68k must have memory aligned to an even boundry)
  stack->ptr -= size + (size & 1);
  
  // Check for stack overflow
  x3d_assert(stack->ptr >= stack->base);
  
  return stack->ptr;
}

///////////////////////////////////////////////////////////////////////////////
/// Returns a stack's current stack pointer, which can be restored with @ref
///   x3d_stack_restore(). This is useful for freeing several stack allocation
///   at once by restoring the stack to its position before the allocations
///   occured.
///
/// @param stack  - stack
///
/// @return The stack's current stack pointer.
///////////////////////////////////////////////////////////////////////////////
void* x3d_stack_save(X3D_Stack* stack) {
  return stack->ptr;
}

///////////////////////////////////////////////////////////////////////////////
/// Sets a stack's stack pointer.
///
/// @param stack  - stack
/// @param ptr    - pointer to set the stack's stack pointer to
///
/// @note See @ref x3d_stack_save().
///////////////////////////////////////////////////////////////////////////////
void x3d_stack_restore(X3D_Stack* stack, void* ptr) {
  x3d_assert(ptr > stack->base && ptr <= stack->base + stack->size);
  
  stack->ptr = ptr;
}

// This file is part of X3D.
//
// X3D is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// X3D is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with X3D. If not, see <http://www.gnu.org/licenses/>.

#include "X3D_common.h"
#include "memory/X3D_varsizeallocator.h"

///////////////////////////////////////////////////////////////////////////////
/// Initializes a variable-sized object allocator.
///
/// @param alloc      - variable-size object allocator
/// @param max_allocs - maximum number of allocations that can be made
/// @param mem_size   - size of memory pool for allocating objects
///
/// @return Nothing.
///////////////////////////////////////////////////////////////////////////////
void x3d_varsizeallocator_init(X3D_VarSizeAllocator* alloc, uint16 max_allocs, uint16 mem_size) {
  uint32 total_size = (uint32)max_allocs * sizeof(uint16) + (uint32)mem_size;
  
  // Max size of allocation in 68k (we do this as one allocation to save space)
  x3d_assert(total_size < 60000);
  
  /// @todo Replace with x3d memory allocation routine
  void* mem = malloc(total_size);
  x3d_assert(mem);
  
  x3d_list_uint16_init(&alloc->alloc_offset, mem, max_allocs * sizeof(uint16));
  x3d_stack_init(&alloc->alloc_pool, mem + max_allocs * sizeof(uint16), mem_size);
}

///////////////////////////////////////////////////////////////////////////////
/// Allocates a variable-sized object from a variable-sized allocator.
///
/// @param alloc  - variable-sized allocator
/// @param size   - size of the object to allocate
/// @param id     - where to write the id of the object being allocated
///
/// @return The address of the allocated object
///////////////////////////////////////////////////////////////////////////////
void* x3d_varsizeallocator_alloc(X3D_VarSizeAllocator* alloc, uint16 size, uint16* id) {
  void* obj = x3d_stack_alloc(&alloc->alloc_pool, size);
  
  /// @todo We shouldn't access the stack's base memory directly
  *id = x3d_list_uint16_add(&alloc->alloc_offset, obj - alloc->alloc_pool.base);
  
  return obj;
}

///////////////////////////////////////////////////////////////////////////////
/// Gets the address of an object allocated with a variable-sized object
///   allocator.
///
/// @param alloc  - variable-sized allocator
/// @param id     - id of the object to get the address for
///
/// @return The address of the object.
///////////////////////////////////////////////////////////////////////////////
void* x3d_varsizeallocator_get(X3D_VarSizeAllocator* alloc, uint16 id) {
  x3d_assert(id < alloc->alloc_offset.size);
  
  return alloc->alloc_pool.base + x3d_list_uint16_get(&alloc->alloc_offset, id);
}

// This file is part of X3D.
//
// X3D is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// X3D is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with X3D. If not, see <http://www.gnu.org/licenses/>.

#include <stdio.h>

#include "X3D_common.h"
#include "memory/X3D_freelist.h"
#include "X3D_assert.h"

///////////////////////////////////////////////////////////////////////////////
/// Creates a new freelist for allocating fixed-sized blocks.
///
/// @param list                 - freelist
/// @param mem                  - memory to partition into blocks
/// @param mem_size             - size of the memory to partition
/// @param block_size           - size of blocks in the freelist
/// @param next_pointer_offset  - an offset from the beginning of each block
///     that is safe to overwrite with a pointer.
/// @param block_id_offset      - an offset from the beginning of each block
///     where the id of the block should be written (as a uint16). This is
///     optional (pass X3D_FREELIST_NO_BLOCK_ID to disable).
/// @param id                   - unique id of the freelist (for debugging)
///
/// @note mem_size MUST be a multiple of block_size!
///////////////////////////////////////////////////////////////////////////////
void x3d_freelist_create(X3D_FreeList* list, void* mem, uint16 mem_size,
    int16 block_size, int16 next_pointer_offset, int16 block_id_offset,
    int16 id) {

  // Only allow sizes that are the multiple of the block size
  x3d_assert((mem_size % block_size) == 0);
  
  // Check to make sure id and next pointer fit within the struct
  x3d_assert(next_pointer_offset + sizeof(void *) <= block_size);
  x3d_assert(block_id_offset + sizeof(uint16) <= block_size);
  
  list->begin = mem;
  list->end = list->begin + mem_size;
  list->block_size = block_size;
  list->next_pointer_offset = next_pointer_offset;
  list->id = id;
  
  int16 block_id = 0;
  void* block = list->begin - list->block_size;
  void** next_ptr;
  
  printf("Size = %lu\n", sizeof(void *));
  
  do {
    block += list->block_size;
    
    // Write in the id of the current block, if enabled
    if(block_id_offset != X3D_FREELIST_NO_BLOCK_ID) {
      uint16* id_ptr = (uint16 *)(block + block_id_offset);  
      *id_ptr = block_id++;
    }

    // Pointer to the pointer to the next block
    next_ptr = (void **)(block + list->next_pointer_offset);
    *next_ptr = block + list->block_size;
  } while(block + list->block_size < list->end);
  
  // Last block doesn't have a next block...
  *next_ptr = NULL;
  
  x3d_assert(block == list->end - list->block_size);
  
  list->head = list->begin;
  list->tail = block;
  
  x3d_log(X3D_INFO, "Created freelist %d with %d blocks (block size=%d bytes, "
    "id_offset=%d, next_ptr_offset=%d)", id, block_id, block_size,
    block_id_offset, next_pointer_offset);
}

void* x3d_freelist_alloc(X3D_FreeList* list) {
  if(list->head) {
    void* block = list->head;
    void** next = (void **)(block + list->next_pointer_offset);
    
    list->head = *next;
    return block;
  }
  
  x3d_assert(!"Out of blocks");
  
  /// @todo throw an error because we're out of blocks!!!
}

///////////////////////////////////////////////////////////////////////////////
/// Returns a block to a freelist.
///
/// @param list   - list
/// @param block  - block to return
///
/// @return Nothing.
///////////////////////////////////////////////////////////////////////////////
void x3d_freelist_free(X3D_FreeList* list, void* block) {
  x3d_assert(block);
  
  void** block_next = (void **)(block + list->next_pointer_offset);
  *block_next = NULL;
    
  // Make sure the block begin freed actually came from the list
  x3d_assert(block >= list->begin && block + list->block_size <= list->end);
  x3d_assert(((block - list->begin) % list->block_size) == 0);
  
  if(list->head) {
    // Add the block to the tail of the queue
    void** next = (void **)(list->tail + list->next_pointer_offset);
    *next = block;
    
    list->tail = block;
  }
  else {
    list->tail = block;
    list->head = block;
  }
}

///////////////////////////////////////////////////////////////////////////////
/// Finds the addess of a block from a freelist given its id.
///
/// @param list - list
/// @param id   - id of the block to find
///
/// @return Address of the block.
///////////////////////////////////////////////////////////////////////////////
void* x3d_freelist_get_block(X3D_FreeList* list, int16 id) {
  int16 total_blocks = (list->end - list->begin) / list->block_size;  
  x3d_assert(id >= 0 && id < total_blocks);
  
  return list->begin + id * list->block_size;
}

// This file is part of X3D.
//
// X3D is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// X3D is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with X3D. If not, see <http://www.gnu.org/licenses/>.

typedef enum {
  X3D_RESOURCE_MEM,
  X3D_RESOURCE_FILE,
} X3D_ResourceType;

typedef struct X3D_Resource {
  X3D_ResourceType type;
  void* resource;
} X3D_Resource;

typedef struct X3D_ResourceStack {
  
} X3D_ResourceStack;



void x3d_alloc_mem() {
  
}

void* x3d_transaction_begin() {
  
}

void x3d_transaction_end(void* transaction) {
  
}




void x3d_add_persistant_resource() {
  
}


// This file is part of X3D.
//
// X3D is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// X3D is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with X3D. If not, see <http://www.gnu.org/licenses/>.

#include "X3D_common.h"
#include "X3D_matrix.h"
#include "X3D_trig.h"
#include "X3D_vector.h"
#include "X3D_prism.h"

/**
* Constructs a 3D prism with regular polygons as the base.
*
* @param s          - pointer to the dest prism
* @param steps      - number of "steps" i.e. points on the polygon base
* @param r          - radius of the base
* @param h          - height of the rism
* @param rot_angle  - angles of rotation around its origin
*
* @return nothing
* @note @ref X3D_Prism is a variable-sized data structure. Make sure s is
*     at least sizeof(X3D_Prism) + sizeof(X3D_Vex3D_int16) * steps * 2 bytes big!
*/
void x3d_prism3d_construct(X3D_Prism3D* s, uint16 steps, uint16 r, int16 h, X3D_Vex3D_angle256 rot_angle) {
  ufp8x8 angle = 0;
  ufp8x8 angle_step = 65536L / steps;
  uint16 i;

  s->base_v = steps;

  // Construct the two bases (regular polygons)
  for(i = 0; i < steps; ++i) {
    s->v[i].x = mul_fp0x16_by_int16_as_int16(x3d_cos(x3d_uint16_upper(angle)), r);
    s->v[i].z = mul_fp0x16_by_int16_as_int16(x3d_sin(x3d_uint16_upper(angle)), r);
    s->v[i].y = -h / 2;

    s->v[i + steps].x = s->v[i].x;
    s->v[i + steps].z = s->v[i].z;
    s->v[i + steps].y = h / 2;

    angle += angle_step;
  }

  // Rotate the prism around its center
  X3D_Mat3x3_fp0x16 mat;
  x3d_mat3x3_construct(&mat, &rot_angle);

  for(i = 0; i < steps * 2; ++i) {
    X3D_Vex3D_int16 rot;

    x3d_vex3d_int16_rotate(&rot, &s->v[i], &mat);
    s->v[i] = rot;
  }
}

// This file is part of X3D.
//
// X3D is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// X3D is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with X3D. If not, see <http://www.gnu.org/licenses/>.

#include <string.h>
#include <stdio.h>

#include "X3D_common.h"
#include "X3D_matrix.h"
#include "X3D_vector.h"
#include "X3D_trig.h"

///////////////////////////////////////////////////////////////////////////////
/// Multiplies two fp0x16 matricies together (aka matrix concatenation).
///
/// @param dest - pointer to the destination matrix
/// @param a    - pointer to the first matrix to multiply
/// @param b    - pointer to the second matrix to multiply
///
/// @return nothing
/// @note dest must not be an alias for a or b
///////////////////////////////////////////////////////////////////////////////
void x3d_mat3x3_mul(X3D_Mat3x3* dest, X3D_Mat3x3* a, X3D_Mat3x3* b) {
  int i, j, k;

  for(i = 0; i < 9; i++)
    dest->data[i] = 0;

  for(i = 0; i < 3; i++) {
    for(j = 0; j < 3; j++) {
      for(k = 0; k < 3; k++) {
        dest->data[MAT3x3(i, j)] += x3d_fp0x16_mul(a->data[MAT3x3(i, k)], b->data[MAT3x3(k, j)]);
      }
    }
  }
}

///////////////////////////////////////////////////////////////////////////////
/// Constructs an fp0x16 3D rotation matrix from a set of Euler anglers.
///
/// @param dest    - pointer to the destination matrix
/// @param angle   - pointer to Vex3D of angles describing rotation around
///    x, y, and z axis.
///
/// @return nothing
/// @todo Add support for rotation around Z axis.
/// @todo Construct matrix using product-to-sum identities instead of matrix
///    multiplication.
///////////////////////////////////////////////////////////////////////////////
void x3d_mat3x3_construct(X3D_Mat3x3_fp0x16 *dest, X3D_Vex3D_angle256 *angle) {
#if 1

  fp0x16 sin_y = x3d_sin(angle->y);
  fp0x16 cos_y = x3d_cos(angle->y);

  fp0x16 sin_x = x3d_sin(angle->x);
  fp0x16 cos_x = x3d_cos(angle->x);

  X3D_Mat3x3 mat_y = {
    {
      cos_y, 0, sin_y,
      0, INT16_MAX, 0,
      -sin_y, 0, cos_y
    }
  };

  X3D_Mat3x3 mat_x = {
    {
      INT16_MAX, 0, 0,
      0, cos_x, -sin_x,
      0, sin_x, cos_x,
    }
  };

  X3D_Mat3x3 mul_res;

  x3d_mat3x3_mul(&mul_res, &mat_y, &mat_x);

  memcpy(dest, &mul_res, sizeof(X3D_Mat3x3));
#endif
}

///////////////////////////////////////////////////////////////////////////////
/// Prints out a 3x3 matrix.
///
/// @param mat  - the matrix to print out
///
/// @return Nothing.
///////////////////////////////////////////////////////////////////////////////
void x3d_mat3x3_print(X3D_Mat3x3* mat) {
  uint16 r;

  for(r = 0; r < 3; ++r) {
    printf("%d %d %d\n", mat->data[MAT3x3(r, 0)], mat->data[MAT3x3(r, 1)], mat->data[MAT3x3(r, 2)]);
  }
}

// This file is part of X3D.
//
// X3D is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// X3D is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with X3D. If not, see <http://www.gnu.org/licenses/>.

#include "X3D_common.h"
#include "X3D_trig.h"

fp0x16 x3d_sin(angle256 angle) {
  /// A table of fp0x16 sin values for angle256
  static const fp0x16 sintab[256] = {
    0, 804, 1607, 2410, 3211, 4011, 4808, 5602, 6392, 7179,
    7961, 8739, 9512, 10278, 11039, 11793, 12539, 13278, 14010, 14732,
    15446, 16151, 16846, 17530, 18204, 18868, 19519, 20159, 20787, 21403,
    22005, 22594, 23170, 23732, 24279, 24812, 25330, 25832, 26319, 26790,
    27245, 27684, 28106, 28511, 28898, 29269, 29621, 29956, 30273, 30572,
    30852, 31114, 31357, 31581, 31785, 31971, 32138, 32285, 32413, 32521,
    32610, 32679, 32728, 32758, 32767, 32758, 32728, 32679, 32610, 32521,
    32413, 32285, 32138, 31971, 31785, 31581, 31357, 31114, 30852, 30572,
    30273, 29956, 29621, 29269, 28898, 28511, 28106, 27684, 27245, 26790,
    26319, 25832, 25330, 24812, 24279, 23732, 23170, 22594, 22005, 21403,
    20787, 20159, 19519, 18868, 18204, 17530, 16846, 16151, 15446, 14732,
    14010, 13278, 12539, 11793, 11039, 10278, 9512, 8739, 7961, 7179,
    6392, 5602, 4808, 4011, 3211, 2410, 1607, 804, 0, -804,
    -1607, -2410, -3211, -4011, -4808, -5602, -6392, -7179, -7961, -8739,
    -9512, -10278, -11039, -11793, -12539, -13278, -14010, -14732, -15446, -16151,
    -16846, -17530, -18204, -18868, -19519, -20159, -20787, -21403, -22005, -22594,
    -23170, -23732, -24279, -24812, -25330, -25832, -26319, -26790, -27245, -27684,
    -28106, -28511, -28898, -29269, -29621, -29956, -30273, -30572, -30852, -31114,
    -31357, -31581, -31785, -31971, -32138, -32285, -32413, -32521, -32610, -32679,
    -32728, -32758, -32767, -32758, -32728, -32679, -32610, -32521, -32413, -32285,
    -32138, -31971, -31785, -31581, -31357, -31114, -30852, -30572, -30273, -29956,
    -29621, -29269, -28898, -28511, -28106, -27684, -27245, -26790, -26319, -25832,
    -25330, -24812, -24279, -23732, -23170, -22594, -22005, -21403, -20787, -20159,
    -19519, -18868, -18204, -17530, -16846, -16151, -15446, -14732, -14010, -13278,
    -12539, -11793, -11039, -10278, -9512, -8739, -7961, -7179, -6392, -5602,
    -4808, -4011, -3211, -2410, -1607, -804
  };
  
  return sintab[(uint16)angle];
}


/// @todo fix formatting
/**
* Calculates the tangent of an angle.
*
* @param angle - the angle as an angle256
*
* @return The tangent of the angle in fp8x8 format
* @note If angle is ANG_90 or ANG_270, this returns @ref VERTICAL_LINE_SLOPE
*/
fp8x8 x3d_tan(angle256 angle) {
  // Prevent division by 0
  if(angle == ANG_90 || angle == ANG_270)
    return VERTICAL_LINE_SLOPE;

  return div_fp0x16_by_fp0x16(x3d_sin(angle), x3d_cos(angle));
}

// This file is part of X3D.
//
// X3D is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// X3D is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with X3D. If not, see <http://www.gnu.org/licenses/>.

#include "X3D_common.h"
#include "X3D_vector.h"
#include "X3D_assert.h"
#include "X3D_enginestate.h"
#include "X3D_screen.h"
#include "X3D_matrix.h"

///////////////////////////////////////////////////////////////////////////////
/// Calculates the dot product of two 16-bit integer 3D vectors.
///
/// @param a - pointer to the first 3D vector
/// @param b - pointer to the the second 3D vector
///
/// @return dot product of a and b as an int32
/// @note This function has the *potential* to overflow, but this has yet to be
///   seen in practice (it requires huge vectors). If overflow does happen, the
///   function calling this should scale down the vectors before calling this.
///////////////////////////////////////////////////////////////////////////////
int32 x3d_vex3d_int16_dot(X3D_Vex3D* a, X3D_Vex3D* b) {
  int32 p_x = (int32)a->x * b->x;
  int32 p_y = (int32)a->y * b->y;
  int32 p_z = (int32)a->z * b->z;
  
  // Check for overflow
  x3d_assert(!x3d_addi32_check_overflow(3, p_x, p_y, p_z));
  
  return p_x + p_y + p_z; 
}

///////////////////////////////////////////////////////////////////////////////
/// Calculates the dot product of two 0x16 fixed-point 3D vectors.
///
/// @param a - pointer to the first 3D vector
/// @param b - pointer to the second 3D vector
///
/// @return dot product of a and b as an fp0x16
///////////////////////////////////////////////////////////////////////////////
fp0x16 x3d_vex3d_fp0x16_dot(X3D_Vex3D_fp0x16* a, X3D_Vex3D_fp0x16* b) {
  return x3d_vex3d_int16_dot(a, b) >> X3D_NORMAL_BITS;
}

/// @todo clean up formatting

#if 0

void x3d_normalize_vex2d_fp0x16(Vex2D_fp0x16* v) {
  int32 distance_squared = 
    (((int32)v->x * v->x)) +
    (((int32)v->y * v->y));
    
  // If distance_squared is negative, the only possible explaination is that
  // it overflowed (should never happen because we divide each term by 4)
  x3d_errorif(distance_squared <= 0, "normalize overflow");
  
  
  // Calculate the actual length of the vector
  // Notice that we multiply the square root by 2 and add 1: we multiply by 2
  // because distance_squared is actually (x^2 + y^2 + z^2) / 4, so
  // sqrt((x^2 + y^2 + z^2) / 4) = .5 * sqrt(x^2 + y^2 + z^2). Thus, we multiply
  // by 2 to get the real result. We add 1 to prevent division by 0 and to make
  // sure we never get 0x8000 after the division (because that's to big to fit in
  // an int16)
  uint16 len = (x3d_fastsqrt(distance_squared));
  
  
  
  /// @todo Add check to make sure the sign of the components is the same after
  /// dividing?
  
  if(len == 0) {
    x3d_error("NORMALIZE 2D ERROR\n");
  }
  
  // Divide each component by the length
  /// @todo Replace with fixed point division
  
  //x3d_errorif(abs(v->x) == len, "v->x == len");
  //x3d_errorif(abs(v->y) == len, "v->y == len");
  
  if(abs(v->y) == len) {
    if(v->y < 0) {
      v->y = -0x7FFF;
    }
    else {
      v->y = 0x7FFF;
    }
  }
  else {
    v->y = ((int32)v->y << X3D_NORMAL_SHIFT) / len;
  }
  
  
  
  if(abs(v->x) == len) {
    if(v->x < 0) {
      v->x = -0x7FFF;
    }
    else {
      v->x = 0x7FFF;
    }
  }
  else {
    v->x = ((int32)v->x << X3D_NORMAL_SHIFT) / len;
  }
}

/**
 * Normalizes an fp0x16 3D vector (makes the entire length 1).
 *
 * @param v - pointer to the 3D vector to normalize
 *
 * @return nothing
 */
inline void x3d_vex3d_fp0x16_normalize(Vex3D_fp0x16* v) {
  X3D_STACK_TRACE;
  
  // Calculate x^2 + y^2 + z^2 for the distance formula.
  //
  // We divide each term by 4 to prevent overflow (if x, y, and z are all 0x7FFF,
  // 0x3FFF0001 + 0x3FFF0001 + 0x3FFF0001 = 0xBFFD0003, which is too big to fit
  // in an int32. However, dividing each term by 4 would give
  // 0x0FFFC000 + 0x0FFFC000 + 0x0FFFC000 = 0x2FFF4000, which fits. Since scaling
  // a vector changes its magnitude but not direction (and in the end we want the
  // length to be 1 anyway), we can do this.
  //
  // Note: we can't divide by 4 after adding because by then it may have already
  // overflowed!
  int32 distance_squared =
    (((int32)v->x * v->x) >> 2) +
    (((int32)v->y * v->y) >> 2) +
    (((int32)v->z * v->z) >> 2);


  // If distance_squared is negative, the only possible explaination is that
  // it overflowed (should never happen because we divide each term by 4)
  x3d_errorif(distance_squared < 0, "normalize overflow");


  // Calculate the actual length of the vector
  // Notice that we multiply the square root by 2 and add 1: we multiply by 2
  // because distance_squared is actually (x^2 + y^2 + z^2) / 4, so
  // sqrt((x^2 + y^2 + z^2) / 4) = .5 * sqrt(x^2 + y^2 + z^2). Thus, we multiply
  // by 2 to get the real result. We add 1 to prevent division by 0 and to make
  // sure we never get 0x8000 after the division (because that's to big to fit in
  // an int16)
  uint16 len = (x3d_fastsqrt(distance_squared) << 1) + 1;


  /// @todo Add check to make sure the sign of the components is the same after
  /// dividing?

  // Divide each component by the length
  /// @todo Replace with fixed point division
  v->x = ((int32)v->x << X3D_NORMAL_SHIFT) / len;
  v->y = ((int32)v->y << X3D_NORMAL_SHIFT) / len;
  v->z = ((int32)v->z << X3D_NORMAL_SHIFT) / len;
}

/**
 * Prints out an int16 Vex3D on the screen.
 *
 * @param v - pointer to the 3D vector to print.
 *
 * @return nothing
 */
void x3d_vex3d_int16_print(X3D_Vex3D_int16* v) {
  printf("{%d, %d, %d}\n", v->x, v->y, v->z);
}

#endif

/**
* Projects a 3D point onto a screen.
*
* @param dest - destination vector
* @param src - source vector
* @param context - rendering context
*
* @return nothing
* @note If src->z is 0, dest->x and dest->y are set to 0 to prevent division
*     by 0.
*/
void x3d_vex3d_int16_project(X3D_Vex2D_int16* dest, const X3D_Vex3D_int16* src) {
  const X3D_ScreenManager* screen = x3d_screenmanager_get();
  
  // To prevent division by zero
  if(src->z == 0) {
    dest->x = 0;
    dest->y = 0;
  }
  else {
    // @todo Replace division by src->z with fixed point multiply
    dest->x = ((int32)src->x * screen->scale) / src->z + screen->center.x;
    dest->y = ((int32)src->y * screen->scale) / src->z + screen->center.y;
  }
}


/**
* Rotates a 3D vector around the origin.
*
* @param dest - destination vector
* @param src - source vector
* @param mat - fp0x16 rotation matrix
*
* @return nothing
* @todo Replace with assembly version
*/
void x3d_vex3d_int16_rotate(X3D_Vex3D_int16* dest, X3D_Vex3D_int16* src, X3D_Mat3x3* mat) {
  fp0x16* m = mat->data;
  
  X3D_Vex3D_int16 x = (X3D_Vex3D_int16){ m[MAT3x3(0, 0)], m[MAT3x3(1, 0)], m[MAT3x3(2, 0)] };
  X3D_Vex3D_int16 y = (X3D_Vex3D_int16){ m[MAT3x3(0, 1)], m[MAT3x3(1, 1)], m[MAT3x3(2, 1)] };
  X3D_Vex3D_int16 z = (X3D_Vex3D_int16){ m[MAT3x3(0, 2)], m[MAT3x3(1, 2)], m[MAT3x3(2, 2)] };

  dest->x = x3d_vex3d_fp0x16_dot(&x, src);
  dest->y = x3d_vex3d_fp0x16_dot(&y, src);
  dest->z = x3d_vex3d_fp0x16_dot(&z, src);
}

#if 0

// Calculates the cross product of two vectors. This creates a vector that
// is perpendicular to both vectors
// Note: this routine will normalize the result
void x3d_vex3d_fp0x16_cross(Vex3D_fp0x16* dest, Vex3D_fp0x16* a, Vex3D_fp0x16* b) {
  int32 xxx = ((((int32)a->y * b->z) >> 1) - (((int32)a->z * b->y) >> 1));
  int32 yyy = ((((int32)a->z * b->x) >> 1) - (((int32)a->x * b->z) >> 1));
  int32 zzz = ((((int32)a->x * b->y) >> 1) - (((int32)a->y * b->x) >> 1));

  while(abs(xxx) >= 0x7FFF || abs(yyy) >= 0x7FFF || abs(zzz) >= 0x7FFF) {
    xxx >>= 1;
    yyy >>= 1;
    zzz >>= 1;
  }

  dest->x = xxx;
  dest->y = yyy;
  dest->z = zzz;

  x3d_vex3d_fp0x16_normalize(dest);
}

/// @todo document
uint16 x3d_vex3d_int16_mag(X3D_Vex3D_int16* v) {
  int32 distance_squared =
    (((int32)v->x * v->x) >> 2) +
    (((int32)v->y * v->y) >> 2) +
    (((int32)v->z * v->z) >> 2);

  return (x3d_fastsqrt(distance_squared) << 1) + 1;
}

#endif